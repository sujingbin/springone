<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_70">13.2 原型模式的定义</h3>

  <p class="ziti">原型模式（Prototype Pattern）的简单程度仅次于单例模式和迭代器模式。正是由于简单，使用的场景才非常地多，其定义如下：</p>

  <p class="ziti">Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）</p>

  <p class="ziti">原型模式的通用类图如图13-3所示。</p>

  <p class="pic"><img alt="" src="../Images/image00417.jpeg"/></p>

  <p class="middle-img">图13-3 原型模式的通用类图</p>

  <p class="ziti">简单，太简单了！原型模式的核心是一个clone方法，通过该方法进行对象的拷贝，Java提供了一个Cloneable接口来标示这个对象是可拷贝的，为什么说是“标示”呢？翻开JDK的帮助看看Cloneable是一个方法都没有的，这个接口只是一个标记作用，在JVM中具有这个标记的对象才有可能被拷贝。那怎么才能从“有可能被拷贝”转换为“可以被拷贝”呢？方法是覆盖clone()方法，是的，你没有看错是重写clone()方法，看看我们上面Mail类中的clone方法，如代码清单13-6所示。</p>

  <p class="ziti">代码清单13-6 邮件类中的clone方法</p>
  <pre>@Override
public Mail clone(){}</pre>

  <p class="ziti">注意，在clone()方法上增加了一个注解@Override，没有继承一个类为什么可以覆写呢？想想看，在Java中所有类的老祖宗是谁？对嘛，Object类，每个类默认都是继承了这个类，所以用覆写是非常正确的——覆写了Object类中的clone方法！</p>

  <p class="ziti">在Java中原型模式是如此简单，我们来看通用源代码，如代码清单13-7所示。</p>

  <p class="ziti">代码清单13-7 原型模式通用源码</p>
  <pre>public class PrototypeClass  implements Cloneable{
     //覆写父类Object方法
     @Override
     public PrototypeClass clone(){
             PrototypeClass prototypeClass = null;
             try {
                    prototypeClass = (PrototypeClass)super.clone();
             } catch (CloneNotSupportedException e) {
                    //异常处理
             }
             return prototypeClass;
     }
}</pre>

  <p class="ziti">实现一个接口，然后重写clone方法，就完成了原型模式！</p>
</body></html>