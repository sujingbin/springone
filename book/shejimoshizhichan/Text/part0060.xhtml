<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_72">13.4 原型模式的注意事项</h3>

  <p class="ziti">原型模式虽然很简单，但是在Java中使用原型模式也就是clone方法还是有一些注意事项的，我们通过几个例子逐个解说。</p>

  <h4 class="p4 sigil_not_in_toc">13.4.1 构造函数不会被执行</h4>

  <p class="ziti">一个实现了Cloneable并重写了clone方法的类A，有一个无参构造或有参构造B，通过new关键字产生了一个对象S，再然后通过S.clone()方式产生了一个新的对象T，那么在对象拷贝时构造函数B是不会被执行的。我们来写一小段程序来说明这个问题，如代码清单13-8所示。</p>

  <p class="ziti">代码清单13-8 简单的可拷贝对象</p>
  <pre>public class Thing implements Cloneable{
     public Thing(){
             System.out.println("构造函数被执行了...");
     }
     @Override
     public Thing clone(){
             Thing thing=null;
             try {
                    thing = (Thing)super.clone();
             } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
             }
             return thing;
     }
}</pre>

  <p class="ziti">然后我们再来写一个Client类，进行对象的拷贝，如代码清单13-9所示。</p>

  <p class="ziti">代码清单13-9 简单的场景类</p>
  <pre>public class Client {
     public static void main(String[] args) {
             //产生一个对象
             Thing thing = new Thing();
             //拷贝一个对象
             Thing cloneThing = thing.clone();
     }
}</pre>

  <p class="ziti">运行结果如下所示：</p>

  <p class="ziti5">构造函数被执行了...</p>

  <p class="ziti">对象拷贝时构造函数确实没有被执行，这点从原理来讲也是可以讲得通的，Object类的clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。</p>

  <h4 class="p3 sigil_not_in_toc">13.4.2 浅拷贝和深拷贝</h4>

  <p class="ziti">在解释什么是浅拷贝和什么是深拷贝之前，我们先来看个例子，如代码清单13-10所示。</p>

  <p class="ziti">代码清单13-10 浅拷贝</p>
  <pre>public class Thing implements Cloneable{
     //定义一个私有变量
     private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
     @Override
     public Thing clone(){
             Thing thing=null;
             try {
                    thing = (Thing)super.clone();
             } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
             }
             return thing;
     }
     //设置HashMap的值
     public void setValue(String value){
             this.arrayList.add(value);
     }
     //取得arrayList的值
     public ArrayList&lt;String&gt; getValue(){
             return this.arrayList;
     }
}</pre>

  <p class="ziti">在Thing类中增加一个私有变量arrayLis，类型为ArrayList，然后通过setValue和getValue分别进行设置和取值，我们来看场景类是如何拷贝的，如代码清单13-11所示。</p>

  <p class="ziti">代码清单13-11 浅拷贝测试</p>
  <pre>public class Client {
     public static void main(String[] args) {
             //产生一个对象
             Thing thing = new Thing();
             //设置一个值
             thing.setValue("张三");
             //拷贝一个对象
             Thing cloneThing = thing.clone();
             cloneThing.setValue("李四");
             System.out.println(thing.getValue());
     }
}</pre>

  <p class="ziti">猜想一下运行结果应该是什么？是仅一个“张三”吗？运行结果如下所示：</p>

  <p class="ziti5">[张三，李四]</p>

  <p class="ziti">怎么会这样呢？怎么会有李四呢？是因为Java做了一个偷懒的拷贝动作，Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，你改我改大家都能改，是一种非常不安全的方式，在实际项目中使用还是比较少的（当然，这也是一种“危机”环境的一种救命方式）。你可能会比较奇怪，为什么在Mail那个类中就可以使用String类型，而不会产生由浅拷贝带来的问题呢？内部的数组和引用对象才不拷贝，其他的原始类型比如int、long、char等都会被拷贝，但是对于String类型，Java就希望你把它认为是基本类型，它是没有clone方法的，处理机制也比较特殊，通过字符串池（stringpool）在需要的时候才在内存中创建新的字符串，读者在使用的时候就把String当做基本类使用即可。</p>
  <hr/>

  <p class="ziti6"><span class="yanse">注意</span>　使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变对象。</p>
  <hr/>

  <p class="ziti">浅拷贝是有风险的，那怎么才能深入地拷贝呢？我们修改一下程序就可以深拷贝，如代码清单13-12所示。</p>

  <p class="ziti">代码清单13-12 深拷贝</p>
  <pre>public class Thing implements Cloneable{
     //定义一个私有变量
     private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
     @Override
     public Thing clone(){
             Thing thing=null;
             try {
                    thing = (Thing)super.clone();
                    thing.arrayList = (ArrayList&lt;String&gt;)this.arrayList.clone();
             } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
             }
             return thing;
     }
}</pre>

  <p class="ziti">仅仅增加了粗体部分，对私有的类变量进行独立的拷贝。Client类没有任何改变，运行结果如下所示：</p>

  <p class="ziti5">[张三]</p>

  <p class="ziti">该方法就实现了完全的拷贝，两个对象之间没有任何的瓜葛了，你修改你的，我修改我的，不相互影响，这种拷贝就叫做深拷贝。深拷贝还有一种实现方式就是通过自己写二进制流来操作对象，然后实现对象的深拷贝，这个大家有时间自己实现一下。</p>
  <hr/>

  <p class="ziti6"><span class="yanse">注意</span>　深拷贝和浅拷贝建议不要混合使用，特别是在涉及类的继承时，父类有多个引用的情况就非常复杂，建议的方案是深拷贝和浅拷贝分开实现。</p>
  <hr/>

  <h4 class="p3 sigil_not_in_toc">13.4.3 clone与final两个冤家</h4>

  <p class="ziti">对象的clone与对象内的final关键字是有冲突的，我们举例来说明这个问题，如代码清单13-13所示。</p>

  <p class="ziti">代码清单13-13 增加final关键字的拷贝</p>
  <pre>public class Thing implements Cloneable{
     //定义一个私有变量
     private final ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
     @Override
     public Thing clone(){
             Thing thing=null;
             try {
                    thing = (Thing)super.clone();       
                    this.arrayList = (ArrayList&lt;String&gt;)this.arrayList.clone();
             } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
             }
             return thing;
     }
}</pre>

  <p class="ziti">粗体部分仅仅增加了一个final关键字，然后编译器就报斜体部分错误，正常呀，final类型你还想重赋值呀！你要实现深拷贝的梦想在final关键字的威胁下破灭了，路总是有的，我们来想想怎么修改这个方法：删除掉final关键字，这是最便捷、安全、快速的方式。你要使用clone方法，在类的成员变量上就不要增加final关键字。</p>
  <hr/>

  <p class="ziti6"><span class="yanse">注意</span>　要使用clone方法，类的成员变量上不要增加final关键字。</p>
  <hr/>
</body></html>