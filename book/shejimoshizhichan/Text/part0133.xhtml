<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_162">29.3 桥梁模式的应用</h3>

  <h4 class="p4 sigil_not_in_toc">29.3.1 桥梁模式的优点</h4>

  <p class="ziti">● 抽象和实现分离</p>

  <p class="ziti">这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。</p>

  <p class="ziti">● 优秀的扩充能力</p>

  <p class="ziti">看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。</p>

  <p class="ziti">● 实现细节对客户透明</p>

  <p class="ziti">客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</p>

  <h4 class="p4 sigil_not_in_toc">29.3.2 桥梁模式的使用场景</h4>

  <p class="ziti">● 不希望或不适用使用继承的场景</p>

  <p class="ziti">例如继承层次过渡、无法更细化设计颗粒等场景，需要考虑使用桥梁模式。</p>

  <p class="ziti">● 接口或抽象类不稳定的场景</p>

  <p class="ziti">明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的，也是比较失败的做法。</p>

  <p class="ziti">● 重用性要求较高的场景</p>

  <p class="ziti">设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。</p>

  <h4 class="p4 sigil_not_in_toc">29.3.3 桥梁模式的注意事项</h4>

  <p class="ziti">桥梁模式是非常简单的，使用该模式时主要考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，那还要继承干什么呢？桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。因此读者在进行系统设计时，发现类的继承有N层时，可以考虑使用桥梁模式。</p>
</body></html>