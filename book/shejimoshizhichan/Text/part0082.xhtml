<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_99">18.3 策略模式的应用</h3>

  <h4 class="p4 sigil_not_in_toc">18.3.1 策略模式的优点</h4>

  <p class="ziti">● 算法可以自由切换</p>

  <p class="ziti">这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。</p>

  <p class="ziti">● 避免使用多重条件判断</p>

  <p class="ziti">如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。</p>

  <p class="ziti">● 扩展性良好</p>

  <p class="ziti">这甚至都不用说是它的优点，因为它太明显了。在现有的系统中增加一个策略太容易了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符合了OCP原则。</p>

  <h4 class="p4 sigil_not_in_toc">18.3.2 策略模式的缺点</h4>

  <p class="ziti">● 策略类数量增多</p>

  <p class="ziti">每一个策略都是一个类，复用的可能性很小，类数量增多。</p>

  <p class="ziti">● 所有的策略类都需要对外暴露</p>

  <p class="ziti">上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。</p>

  <h4 class="p4 sigil_not_in_toc">18.3.3 策略模式的使用场景</h4>

  <p class="ziti">● 多个类只有在算法或行为上稍有不同的场景。</p>

  <p class="ziti">● 算法需要自由切换的场景。</p>

  <p class="ziti">例如，算法的选择是由使用者决定的，或者算法始终在进化，特别是一些站在技术前沿的行业，连业务专家都无法给你保证这样的系统规则能够存在多长时间，在这种情况下策略模式是你最好的助手。</p>

  <p class="ziti">● 需要屏蔽算法规则的场景。</p>

  <p class="ziti">现在的科技发展得很快，人脑的记忆是有限的（就目前来说是有限的），太多的算法你只要知道一个名字就可以了，传递相关的数字进来，反馈一个运算结果，万事大吉。</p>

  <h4 class="p4 sigil_not_in_toc">18.3.4 策略模式的注意事项</h4>

  <p class="ziti">如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。</p>
</body></html>