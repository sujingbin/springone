<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_15">3.3 依赖的三种写法</h3>

  <p class="ziti">依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D……生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！</p>

  <p class="ziti">对象的依赖关系有三种方式来传递，如下所示。</p>

  <p class="yanse">1.构造函数传递依赖对象</p>

  <p class="ziti">在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入，按照这种方式的注入，IDriver和Driver的程序修改后如代码清单3-11所示。</p>

  <p class="ziti">代码清单3-11 构造函数传递依赖对象</p>
  <pre>public interface IDriver {
     //是司机就应该会驾驶汽车
     public void drive();
}
public class Driver implements IDriver{
     private ICar car;  
     //构造函数注入
     public Driver(ICar _car){
              this.car = _car;
     }
     //司机的主要职责就是驾驶汽车
     public void drive(){
             this.car.run();
     }
}</pre>

  <p class="yanse">2.Setter方法传递依赖对象</p>

  <p class="ziti">在抽象中设置Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入，按照这种方式的注入，IDriver和Driver的程序修改后如代码清单3-12所示。</p>

  <p class="ziti">代码清单3-12 Setter依赖注入</p>
  <pre>public interface IDriver {
     //车辆型号
     public void setCar(ICar car);
     //是司机就应该会驾驶汽车
     public void drive();
}
public class Driver implements IDriver{
     private ICar car;  
     public void setCar(ICar car){
             this.car = car;
     }
     //司机的主要职责就是驾驶汽车
     public void drive(){
             this.car.run();
     }
}</pre>

  <p class="yanse">3.接口声明依赖对象</p>

  <p class="ziti">在接口的方法中声明依赖对象，3.2节的例子就采用了接口声明依赖的方式，该方法也叫做接口注入。</p>
</body></html>