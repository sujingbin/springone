<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_64">12.2 代理模式的定义</h3>

  <p class="ziti">代理模式（Proxy Pattern）是一个使用率非常高的模式，其定义如下：</p>

  <p class="ziti">Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p>

  <p class="ziti">代理模式的通用类图如图12-3所示。</p>

  <p class="pic"><img alt="" src="../Images/image00408.jpeg"/></p>

  <p class="middle-img">图12-3 代理模式的通用类图</p>

  <p class="ziti">代理模式也叫做委托模式，它是一项基本设计技巧。许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式，而且在日常的应用中，代理模式可以提供非常好的访问控制。在一些著名开源软件中也经常见到它的身影，如Struts2的Form元素映射就采用了代理模式（准确地说是动态代理模式）。我们先看一下类图中的三个角色的定义：</p>

  <p class="ziti">● Subject抽象主题角色</p>

  <p class="ziti">抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。</p>

  <p class="ziti">● RealSubject具体主题角色</p>

  <p class="ziti">也叫做被委托角色、被代理角色。它才是冤大头，是业务逻辑的具体执行者。</p>

  <p class="ziti">● Proxy代理主题角色</p>

  <p class="ziti">也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。</p>

  <p class="ziti">我们首先来看Subject抽象主题类的通用源码，如代码清单12-6所示。</p>

  <p class="ziti">代码清单12-6 抽象主题类</p>
  <pre>public interface Subject {
     //定义一个方法
     public void request();
}</pre>

  <p class="ziti">在接口中我们定义了一个方法request来作为方法的代表，RealSubject对它进行实现，如代码清单12-7所示。</p>

  <p class="ziti">代码清单12-7 真实主题类</p>
  <pre>public class RealSubject implements Subject {
     //实现方法
     public void request() {
             //业务逻辑处理
     }
}</pre>

  <p class="ziti">RealSubject是一个正常的业务实现类，代理模式的核心就在代理类上，如代码清单12-8所示。</p>

  <p class="ziti">代码清单12-8 代理类</p>
  <pre>public class Proxy implements Subject {
     //要代理哪个实现类
     private Subject subject = null;    
     //默认被代理者
     public Proxy(){
             this.subject = new Proxy();
     }
     //通过构造函数传递代理者
     public Proxy(Object...objects ){
     }
     //实现接口中定义的方法
     public void request() {
             this.before();
             this.subject.request();
             this.after();
     }
     //预处理
     private void before(){
             //do something
     }
     //善后处理
     private void after(){
             //do something
     }
}</pre>

  <p class="ziti">看到这里，大家别惊讶，为什么会出现before和after方法，继续看下去，这是一个“引子”，能够引出一个崭新的编程模式。</p>

  <p class="ziti">一个代理类可以代理多个被委托者或被代理者，因此一个代理类具体代理哪个真实主题角色，是由场景类决定的。当然，最简单的情况就是一个主题类和一个代理类，这是最简洁的代理模式。在通常情况下，一个接口只需要一个代理类就可以了，具体代理哪个实现类由高层模块来决定，也就是在代理类的构造函数中传递被代理者，例如我们可以在代理类Proxy中增加如代码清单12-9所示的构造函数。</p>

  <p class="ziti">代码清单12-9 代理的构造函数</p>
  <pre>public Proxy(Subject _subject){
     this.subject = _subject;
}</pre>

  <p class="ziti">你要代理谁就产生该代理的实例，然后把被代理者传递进来，该模式在实际的项目应用中比较广泛。</p>
</body></html>