<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.250rem;"><head>
  <link href="../Styles/style0001.css" rel="stylesheet" type="text/css"/>

  <title></title>
</head><body>
  <h3 class="p3" id="sigil_toc_id_94">17.3 装饰模式应用</h3>

  <h4 class="p4 sigil_not_in_toc">17.3.1 装饰模式的优点</h4>

  <p class="ziti">● 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。</p>

  <p class="ziti">● 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。</p>

  <p class="ziti">● 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。</p>

  <h4 class="p4 sigil_not_in_toc">17.3.2 装饰模式的缺点</h4>

  <p class="ziti">对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，因此，尽量减少装饰类的数量，以便降低系统的复杂度。</p>

  <h4 class="p4 sigil_not_in_toc">17.3.3 装饰模式的使用场景</h4>

  <p class="ziti">● 需要扩展一个类的功能，或给一个类增加附加功能。</p>

  <p class="ziti">● 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</p>

  <p class="ziti">● 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</p>
</body></html>